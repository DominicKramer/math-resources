Sage handles pre-images just a bit differently than our approach in the text.  For the moment, we can obtain a single vector in the set that is the pre-image via the \verb?.preimage_representative()? method.  Understand that this method will return \emph{just one} element of the pre-image set, and we have no real control over which one.  Also, it is certainly possible that a pre-image is the empty set --- in this case, the method will raise a \verb?ValueError?.  We will use our running example to illustrate.
%
\begin{sageexample}
sage: A = matrix(QQ, [[-1, 0, 2],
...                   [ 1, 3, 7],
...                   [ 1, 1, 1],
...                   [ 2, 3, 5]])
sage: T = linear_transformation(QQ^3, QQ^4, A, side='right')
sage: v = vector(QQ, [1, 2, 0, 1])
sage: u = T.preimage_representative(v)
sage: u
(-1, 1, 0)
sage: T(u) == v
True
sage: T.preimage_representative(vector(QQ, [1, 2, 1, 1]))
Traceback (most recent call last):
...
ValueError: element is not in the image
\end{sageexample}
%
Remember, we have defined the pre-image as a set, and Sage just gives us a single element of the set.  We will see in \acronymref{sage}{ILT} that the upcoming \acronymref{theorem}{KPI} explains why this is no great shortcoming in Sage.
%
\begin{sageverbatim}
\end{sageverbatim}
%




