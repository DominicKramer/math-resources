Sage has the matrix method \verb?.pivot()? to quickly and easily identify the pivot columns of the reduced row-echelon form of a matrix.  Notice that we do not have to row-reduce the matrix first, we just ask which columns of a matrix $A$ \emph{would be} the pivot columns of the matrix $B$ that is row-equivalent to $A$ and in reduced row-echelon form.  By \acronymref{definition}{IDV}, the indices of the pivot columns for an augmented matrix of a system of equations are the indices of the dependent variables.  And the remainder are free variables.  But be careful, Sage numbers columns starting from zero and mathematicians typically number variables starting from one.\par
%
Let's reprise \acronymref{example}{ISSI}.
%
\begin{sageexample}
sage: coeff = matrix(QQ, [[ 1,  4, 0, -1,  0,   7, -9],
...                       [ 2,  8,-1,  3,  9, -13,  7],
...                       [ 0,  0, 2, -3, -4,  12, -8],
...                       [-1, -4, 2,  4,  8, -31, 37]])
sage: const = vector(QQ, [3, 9, 1, 4])
sage: aug = coeff.augment(const)
sage: dependent = aug.pivots()
sage: dependent
(0, 2, 3)
\end{sageexample}
%
So, incrementing each column index by 1 gives us the same set $D$ of indices for the dependent variables.  To get the free variables, we can use the following code.  Study it and then read the explanation following.
%
\begin{sageexample}
sage: free = [index for index in range(7) if not index in dependent]
sage: free
[1, 4, 5, 6]
\end{sageexample}
%
This is a Python programming construction known as a ``list comprehension'' but in this setting I prefer to call it ``set builder notation.''  Let's dissect the command in pieces.  The brackets (\verb?[,]?) create a new list.  The items in the list will be values of the variable \verb?index?.  \verb?range(7)? is another list, integers starting at \verb?0? and stopping \emph{just before} \verb?7?.  (While perhaps a bit odd, this works very well when we consistently start counting at zero.) So \verb?range(7)? is the list \verb?[0,1,2,3,4,5,6]?.  Think of these as candidate values for \verb?index?, which are generated by \texttt{for index in range(7)}.  Then we test each candidate, and keep it in the new list if it is \emph{not} in the list \verb?dependent?.\par
%
This is entirely analogous to the following mathematics:
%
\begin{align*}
F &= \setparts{f}{1\leq f\leq 7, f\not\in D}
\end{align*}
%
where $F$ is \verb?free?, $f$ is \verb?index?, and $D$ is \verb?dependent?, and we make the 0/1 counting adjustments.  This ability to construct sets in Sage with notation so closely mirroring the mathematics is a powerful feature worth mastering.  We will use it repeatedly.
%
It was a good exercise to use a list comprehension to form the list of columns that are not pivot columns.  However, Sage has us covered.
%
\begin{sageexample}
sage: free_and_easy = coeff.nonpivots()
sage: free_and_easy
(1, 4, 5, 6)
\end{sageexample}
%
Can you use this new matrix method to make a simpler version of the \verb?consistent()? function we designed above?


%
\begin{sageverbatim}
\end{sageverbatim}
%